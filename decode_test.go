package nbt

import (
	"os"
	"reflect"
	"testing"
)

type ServerList struct {
	Servers []Server `nbt:"servers"`
}

type Server struct {
	Name string `nbt:"name"`
	IP   string `nbt:"ip"`
}

func assertString(t *testing.T, name, a, b string) {
	if a != b {
		t.Errorf("%s == %#v != %#v", name, a, b)
	}
}

func TestServerList(t *testing.T) {
	f, err := os.Open("testcases/servers.dat")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	var list ServerList

	err = Unmarshal(Uncompressed, f, &list)
	if err != nil {
		t.Error(err)
	}

	if len(list.Servers) != 3 {
		t.Errorf("Server list length is %d, but expected 3.", len(list.Servers))
	}

	assertString(t, "Servers[0].Name", list.Servers[0].Name, "Who")
	assertString(t, "Servers[0].IP", list.Servers[0].IP, "what.invalid")

	assertString(t, "Servers[1].Name", list.Servers[1].Name, "Where")
	assertString(t, "Servers[1].IP", list.Servers[1].IP, "when:12345")

	assertString(t, "Servers[2].Name", list.Servers[2].Name, "☃")
	assertString(t, "Servers[2].IP", list.Servers[2].IP, "snow.man")
}

type MapServerList struct {
	Servers []map[string]interface{} `nbt:"servers"`
}

func TestMapDecode(t *testing.T) {
	f, err := os.Open("testcases/servers.dat")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	var list MapServerList

	err = Unmarshal(Uncompressed, f, &list)
	if err != nil {
		t.Error(err)
	}

	if len(list.Servers) != 3 {
		t.Errorf("Server list length is %d, but expected 3.", len(list.Servers))
	}

	assertString(t, "Servers[0].Name", list.Servers[0]["name"].(string), "Who")
	assertString(t, "Servers[0].IP", list.Servers[0]["ip"].(string), "what.invalid")

	assertString(t, "Servers[1].Name", list.Servers[1]["name"].(string), "Where")
	assertString(t, "Servers[1].IP", list.Servers[1]["ip"].(string), "when:12345")

	assertString(t, "Servers[2].Name", list.Servers[2]["name"].(string), "☃")
	assertString(t, "Servers[2].IP", list.Servers[2]["ip"].(string), "snow.man")
}

func TestMapDecode2(t *testing.T) {
	f, err := os.Open("testcases/servers.dat")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	var list map[string]interface{}

	err = Unmarshal(Uncompressed, f, &list)
	if err != nil {
		t.Error(err)
	}

	servers := list["servers"].([]interface{})

	if len(servers) != 3 {
		t.Errorf("Server list length is %d, but expected 3.", len(servers))
	}

	assertString(t, "Servers[0].Name", servers[0].(map[string]interface{})["name"].(string), "Who")
	assertString(t, "Servers[0].IP", servers[0].(map[string]interface{})["ip"].(string), "what.invalid")

	assertString(t, "Servers[1].Name", servers[1].(map[string]interface{})["name"].(string), "Where")
	assertString(t, "Servers[1].IP", servers[1].(map[string]interface{})["ip"].(string), "when:12345")

	assertString(t, "Servers[2].Name", servers[2].(map[string]interface{})["name"].(string), "☃")
	assertString(t, "Servers[2].IP", servers[2].(map[string]interface{})["ip"].(string), "snow.man")
}

type EmptyServerList struct {
}

func TestErrMissingField(t *testing.T) {
	f, err := os.Open("testcases/servers.dat")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	var list EmptyServerList

	err = Unmarshal(Uncompressed, f, &list)
	if err == nil {
		t.Error("No error, but one was expected!")
	} else if err.Error() != "nbt: Unhandled tagList (0x09)\n\t\tat struct field \"servers\"" {
		t.Error(err)
	}
}

type WronglyTypedServerList struct {
	Servers []WronglyTypedServer `nbt:"servers"`
}

type WronglyTypedServer struct {
	Name string  `nbt:"name"`
	IP   float64 `nbt:"ip"`
}

func TestErrWrongType(t *testing.T) {
	f, err := os.Open("testcases/servers.dat")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	var list WronglyTypedServerList

	err = Unmarshal(Uncompressed, f, &list)
	if err == nil {
		t.Error("No error, but one was expected!")
	} else if err.Error() != "nbt: Tag is tagString (0x08), but I don't know how to put that in a float64!\n\t\tat struct field \"ip\"\n\t\tat list index 0\n\t\tat struct field \"servers\"" {
		t.Error(err)
	}
}

type BigTest struct {
	ByteTest     int8       `nbt:"byteTest"`
	ShortTest    int16      `nbt:"shortTest"`
	IntTest      int32      `nbt:"intTest"`
	LongTest     int64      `nbt:"longTest"`
	FloatTest    float32    `nbt:"floatTest"`
	DoubleTest   float64    `nbt:"doubleTest"`
	StringTest   string     `nbt:"stringTest"`
	Nested       Nested     `nbt:"nested compound test"`
	LongList     []int64    `nbt:"listTest (long)"`
	CompoundList []ListItem `nbt:"listTest (compound)"`
	ByteArray    []byte     `nbt:"byteArrayTest (the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))"`
}

type Nested struct {
	Ham Food `nbt:"ham"`
	Egg Food `nbt:"egg"`
}

type Food struct {
	Name  string  `nbt:"name"`
	Value float32 `nbt:"value"`
}

type ListItem struct {
	Name    string `nbt:"name"`
	Created uint64 `nbt:"created-on"`
}

func TestBigTest(t *testing.T) {
	f, err := os.Open("testcases/bigtest.nbt")
	if err != nil {
		t.Error(err)
	}
	defer f.Close()

	expected := BigTest{
		ByteTest:   127,
		ShortTest:  32767,
		IntTest:    -1,
		LongTest:   9223372036854775807,
		FloatTest:  0.49823147,
		DoubleTest: 0.4931287132182315,
		StringTest: "HELLO WORLD THIS IS A TEST STRING ÅÄÖ!",
		Nested: Nested{
			Ham: Food{Name: "Hampus", Value: 0.75},
			Egg: Food{Name: "Eggbert", Value: 0.5},
		},
		LongList: []int64{11, 12, 13, 14, 15},
		CompoundList: []ListItem{
			ListItem{
				Name:    "Compound tag #0",
				Created: 0x1265237d58d,
			},
			ListItem{
				Name:    "Compound tag #1",
				Created: 0x1265237d58d,
			},
		},
		ByteArray: []byte{
			0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x4, 0x56,
			0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54,
			0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a,
			0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c,
			0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26,
			0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c,
			0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a,
			0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20,
			0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32,
			0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c,
			0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42,
			0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40,
			0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16,
			0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28,
			0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12,
			0x46, 0x20, 0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38,
			0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36,
			0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc,
			0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e,
			0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8,
			0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e,
			0x26, 0x28, 0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c,
			0x4c, 0x12, 0x46, 0x20, 0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2,
			0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14,
			0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62,
			0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24,
			0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22,
			0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c,
			0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa,
			0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58,
			0x28, 0x2, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a,
			0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18,
			0x38, 0x62, 0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52,
			0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0,
			0xc, 0x22, 0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e,
			0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e, 0x22, 0x10,
			0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe,
			0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48,
			0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a,
			0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44,
			0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x6,
			0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4,
			0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e,
			0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x4, 0x56, 0x4e, 0x50,
			0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a,
			0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60,
			0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e,
			0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34,
			0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46,
			0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x6, 0x30,
			0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x4, 0x56,
			0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54,
			0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a,
			0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42, 0x3a, 0x3c,
			0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26,
			0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16, 0x5e, 0x4c,
			0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a,
			0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20,
			0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38, 0x30, 0x32,
			0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c,
			0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc, 0x54, 0x42,
			0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40,
			0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8, 0x3c, 0x16,
			0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28,
			0x34, 0x4a, 0x6, 0x30, 0x0, 0x3e, 0x22, 0x10, 0x8, 0xa, 0x16, 0x2c, 0x4c, 0x12,
			0x46, 0x20, 0x4, 0x56, 0x4e, 0x50, 0x5c, 0xe, 0x2e, 0x58, 0x28, 0x2, 0x4a, 0x38,
			0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0xa, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36,
			0x56, 0x1c, 0x50, 0x2a, 0xe, 0x60, 0x58, 0x5a, 0x2, 0x18, 0x38, 0x62, 0x32, 0xc,
			0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e,
			0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x6, 0x62, 0x0, 0xc, 0x22, 0x42, 0x8,
			0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x4, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e,
			0x26, 0x28, 0x34, 0x4a, 0x6, 0x30,
		},
	}
	// Gee, I sure hope I'm getting paid by the line...

	var bigTest BigTest

	err = Unmarshal(GZip, f, &bigTest)
	if err != nil {
		t.Error(err)
	}

	left, right := parseStruct(reflect.ValueOf(bigTest)), parseStruct(reflect.ValueOf(expected))
	for field, l := range left {
		r := right[field]

		if !reflect.DeepEqual(l.Interface(), r.Interface()) {
			t.Errorf("Field %s differs:", field)
			t.Logf("Found   : %#v", l)
			t.Logf("Expected: %#v", r)
		}
	}
}
